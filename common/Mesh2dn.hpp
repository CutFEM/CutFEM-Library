
#ifndef MESH2DN_HPP_
#define MESH2DN_HPP_

#include "dataStruct2D.hpp"
#include "GenericMesh.hpp"
#include <cstdlib>


class Interface2;
class TimeInterface2;
class SignPatternTrait2;
class RefPatch2;
class RefPartition2;
class Partition2;

class Mesh2 : public GenericMesh<Triangle2,BoundaryEdge2,Vertex2>
{
public:
  typedef SignPatternTrait2 SignPattern;
  typedef RefPatch2 RefPatch;
  typedef RefPartition2 RefPartition;
  typedef Partition2 Partition;

  // Mesh2() : GenericMesh<Triangle2,BoundaryEdge2,Vertex2>() {};
  Mesh2(const char *);                              // build from mesh generated by Freefem
  Mesh2(int nx, int ny, R orx, R ory, R lx, R ly);  // build structured mesh

  Mesh2(const Interface2& gamma);         // build mesh for interface problem
  Mesh2(TimeInterface2 &gamma);


  // Mesh2(const Mesh2&, std::string whatToDo);
  // void square(int nx, R orx, R ly);


private:
  Mesh2(const Mesh2 &);                             // no copy constructor
  void operator=(const Mesh2 &);                    // no copy allowed
};


class MeshQuad2 : public GenericMesh<Quad2,BoundaryEdge2,Vertex2>
{
public:
  typedef SignPatternTrait2 SignPattern;
  typedef RefPatch2 RefPatch;
  typedef RefPartition2 RefPartition;
  typedef Partition2 Partition;

  // MeshQuad2() : GenericMesh<Quad2,BoundaryEdge2,Vertex2>() {};
  MeshQuad2(int nx, int ny, R orx, R ory, R lx, R ly);  // build structured mesh

  // Mesh2(const Interface2& gamma);         // build mesh for interface problem
  // Mesh2(TimeInterface2 &gamma);


private:
  MeshQuad2(const MeshQuad2 &);                             // no copy constructor
  void operator=(const MeshQuad2 &);                    // no copy allowed
};




///\Brief Represents the reference tetra, which is cut by a linear level set function ls. The values of the latter are prescribed on the vertices.
class SignPatternTrait2 : public GSignPatternTrait<Triangle2>
{

public :
  bool is_2d () const { return num_root_vert_ == 3; }
  bool is_1d () const { return num_root_ > 1; }  ///< True, iff the intersection has positive area.
  friend std::ostream& operator<< (std::ostream&, const SignPatternTrait2&); ///< Debug-output to a stream (dumps all members)

  SignPatternTrait2() : GSignPatternTrait<Triangle2>() {}
  SignPatternTrait2(const byte    ls[3]) : GSignPatternTrait<Triangle2>(ls) {}
  SignPatternTrait2(const double  ls[3]) : GSignPatternTrait<Triangle2>(ls) {}

};


/*
 *  Return a signed array-index for the possible 3^4 sign-patterns on the vertices of a triangle
 *  The index ranges from [-13..13].
 */
inline static byte instance_idx2 (const byte ls[3])
{
  return  9*ls[0] + 3*ls[1] + ls[2];
}

inline static Ubyte instance_idx2 (const double ls[3])
{
  return  9*util::sign( ls[0]) + 3*util::sign( ls[1]) + util::sign( ls[2]);
}



/*
 * The segment of the intersection of the reference-triangle with a linear levelset-function.
 * The class memorizes used sign-patterns
 */
class RefPatch2
{
public:
  static const int nv = 2;

  typedef SortArray<Ubyte, nv> FaceIdx; ///< the vertices of a triangle of the cut: the tetra's vertices are denoted by 0..3, the edge-cuts by edge-num + 4, which is in 4..9.
  typedef const FaceIdx* const_face_iterator;
  typedef       FaceIdx*       face_iterator;

  /// \brief Initializes RefTetraPatchCL::instance_array_ below in the constructor by calling RefTetraPatchCL::instance() for all legal sign patterns.
  class InitializerCL
  {
  private:
    static int init_count_;

  public:
    InitializerCL ();
  };

private:
  FaceIdx face_[1];        ///< at most two triangles
  Ubyte size_;             ///< number of triangles
  Ubyte is_boundary_face_; ///< true if the triangle is one of the tetra's faces.

  Ubyte num_elements (const SignPatternTrait2& cut) const {
    return cut.is_1d() ? 1 : 0; }
  FaceIdx MakeTriangle (Ubyte v0, Ubyte v1) const {
    return FaceIdx( v0, v1); }

  static RefPatch2 instance_array_[27]; // 81 = 3^4 = all possible sign-patterns on the vertices

public:
  RefPatch2 () : size_( static_cast<Ubyte>( -1)), is_boundary_face_( 0) {} ///< Uninitialized default state
  RefPatch2 (const SignPatternTrait2& cut) { assign( cut); } ///< Initialize with sign pattern on the vertices
  bool assign (const SignPatternTrait2& cut); ///< Assign a sign pattern on the vertices; returns the value of empty()

  bool  is_initialized () const { return size_ == 1; } ///< True after assign(...)

  ///@{ Recommended access to the triangles for a given sign-pattern; memoizes the result.
  static inline const RefPatch2& instance (const byte   ls[3]) {
    RefPatch2& instance = instance_array_[instance_idx2 ( ls) + 13];
    if ( !instance.is_initialized()) {
      instance.assign( SignPatternTrait2( ls));
    }
    return instance;
  }
  static inline const RefPatch2& instance (const double ls[3])
  {
    byte ls_byte[3];
    std::transform( ls + 0, ls + 3, ls_byte + 0, util::sign);
    return instance( ls_byte);
  }
  ///@}

//   bool is_boundary_triangle () const { return is_boundary_triangle_ == 1; } ///< true, iff the triangle is one of the tetra's faces.

  bool  empty () const { return size_ == 0; } ///< true, iff the area of the intersection is 0.
  size_t size () const { return size_; }      ///< Number of triangles, 0, 1, or 2

  ///@{ Random-access to the triangles
  const_face_iterator face_begin () const { return face_; }
  const_face_iterator face_end   () const { return face_ + size_; }
  ///@}
};





#endif
